'''
css_demod :: Jackie Schellberg :: 10/19/2023 

Code to demodulate received samples from the USRP according to CSS 

my_channel : unused 

input_queue : rx complex samples 

output_queue : demodulated symbols 
'''

from matplotlib import pyplot as plt
import time
import math
import numpy as np
from scipy import signal, fft

import scipy.io

class CssDemod:
    def __init__(self, N, UPSAMP): 
        '''
        Initialize our CSS demodulator, keeping track of the state. 
        '''
        # we need to keep track if  we have detected the preamble 
        self.PACKET_DETECTED = False 
        
        # Number of samples per symbol = 2^SF 
        self.N = int(N)
        
        # Threshold envelope; at what power level do we expect to see a packet arrive? 
        # For low power scenario, this will have to be substituted 
        #self.DB_THRESH = -15
        self.DB_THRESH = -27
        
        # Upsampling rate 
        self.UPSAMP = UPSAMP 
        
        # Window size, i.e., the size of the preamble 
        self.WINDOW_SIZE = UPSAMP * N
        
        # This is a list to allocate samples as we identify them 
        self.PREV_QUEUE = []
        
        # Redundant; just makes a reference chirp 
        self.UPCHIRP = self.create_upchirp()
        
        # What correlation peaks to we accept in noise conditions? (for xcorr)
        self.THRESH = .98
        
        # this will need to be updated during packet detection 
        #self.PACKET_LEN = 128 + 8 - 1
        self.PACKET_LEN = 57
        #self.PACKET_LEN = 50
        
        # keep track of how many packets we have decoded 
        self.PACKETS_DECODED = 0 
        
        # Leftover queue to be concatenated with the other 
        self.LEFTOVER = [] 
        
        # Doppler correction related 
        self.DOPPLER_CORR = 0 
        
        
        # fft preamble for packet detection 
        self.preamble_fft = fft.fft(self.UPCHIRP)
        
    def css_demod(self, my_channel, queue, output):    
        cosine_sim = np.zeros((math.floor(len(queue)/self.WINDOW_SIZE), 1), complex)
        cross_corr_preamble = np.zeros((self.WINDOW_SIZE, 1), complex)
        k=0
        j=0
        
        for i in np.arange(0, len(queue), self.WINDOW_SIZE):
            print(i)
            #print((i+ self.N - 1))
            #window_1 = queue[i:(i+ self.WINDOW_SIZE - 1)]
            #window_2 = queue[(i+self.WINDOW_SIZE):(i+2*self.WINDOW_SIZE -1)]
            window_1 = queue[i:(i+ self.WINDOW_SIZE )]
            window_2 = queue[(i+self.WINDOW_SIZE):(i+2*self.WINDOW_SIZE )]
            fft_window1 = fft.fft(window_1)
            fft_window2 = fft.fft(window_2)
            print(k)
            cosine_sim[k] = sum(fft_window1 * np.conj(fft_window2)) / \
                            math.sqrt(sum(fft_window1 * np.conjugate(fft_window1)) * \
                            sum(fft_window2 * np.conjugate(fft_window2)))
                            
            # what is the significance of this step?
            cosine_sim_threshold = sum(abs(cosine_sim))/k 
        
            if (k > 1 and abs(cosine_sim[k-1]) >= abs(cosine_sim[k-2]) and \
                abs(cosine_sim[k-1]) >= abs(cosine_sim[k]) and \
                abs(cosine_sim[k-1]) >= cosine_sim_threshold):
                
                for p in range(0,self.WINDOW_SIZE):
                    fft_window = fft.fft(queue[i-self.WINDOW_SIZE+p : i+p]) 
                    cross_corr_preamble[j] = sum(fft_window * np.conjugate(self.preamble_fft)) /\
                                             math.sqrt(sum(fft_window * np.conjugate(fft_window)) * \
                                             sum(self.preamble_fft * np.conjugate(self.preamble_fft)))
                    
                    cross_corr_preamble_threshold = sum(abs(cross_corr_preamble)) / j 
                    
                    if (j > 1) and \
                       (abs(cross_corr_preamble[j-1]) > abs(cross_corr_preamble[j-2])) and \
                       (abs(cross_corr_preamble[j-1]) >= abs(cross_corr_preamble[j])) and \
                       (abs(cross_corr_preamble[j-1]) > cross_corr_preamble_threshold) :
                       
                       SFD = i - self.WINDOW_SIZE + p 
                       self.PACKET_DETECTED = True 
                       break
                    j = j+1 
            k = k+1
            
            if (self.PACKET_DETECTED):
                print("Packet detected")
                print(SFD)
                plt.figure(0)
                xpts = range(0,len(cosine_sim))
                plt.plot(xpts, abs(cosine_sim))
                
                plt.figure(2)
                xpts = range(0,len(queue[i:(i+ 2*self.WINDOW_SIZE )]))
                plt.plot(xpts, abs(queue[i:(i+ 2*self.WINDOW_SIZE )]))
                
                plt.show()
                break
                
    def get_doppler(self, up_chirp, window1): 
        '''
        Corrects doppler shift based on the known preamble 
        '''       
        dechirped_shift = window1 * np.conjugate(up_chirp) 
        dechirped_fft =fft.fft(dechirped_shift) 
        dechirped_fft_shift = np.argmax(abs(dechirped_fft))
        #print(dechirped_fft_shift)
        
        freq_1_shift = self.sym_to_data_ang( [0], self.N, self.UPSAMP) * np.conjugate(up_chirp) 
        freq_1_shift_fft = fft.fft(freq_1_shift)
        freq_1_shift_fft_shift = np.argmax(freq_1_shift_fft)
        #print(freq_1_shift_fft_shift)
        
        freq_bin_shift = dechirped_fft_shift - (freq_1_shift_fft_shift +1)
        
        #print(freq_bin_shift)
        
        return freq_bin_shift
        
    def symbol_demod(self, rx_sig):
        '''
        Demodulates a CSS symbol and returns the frequency bin 
        at which the symbol appears.
        '''
        sig_tmp = rx_sig[:self.WINDOW_SIZE]
        
        trans_upchirp = np.conjugate(self.UPCHIRP)
        dechirped = sig_tmp * trans_upchirp
        dechirped = np.squeeze(dechirped)
        data_fft = abs(fft.fft(dechirped)).transpose()
        
        dechirped = np.concatenate((data_fft[:int(self.N/2)+1], \
                    data_fft[int(self.N/2 + int(self.UPSAMP-1)*self.N + 1):]))
                 
        freq_bin = np.argmax(dechirped)
        #freq_bin = np.argmax(data_fft)
        
        return freq_bin 
        
    def create_upchirp(self):
        '''
        Create an upchirp which is used to demodulate the symbols 
        '''
        return self.sym_to_data_ang([-1],self.N, self.UPSAMP)
        #return self.sym_to_data_ang([0],self.N, self.UPSAMP)
        
    def sym_to_data_ang(self, symbol,N, UPSAMP):
        '''
        Via https://github.com/mananmishra11/open-lora/blob/main/std_lora/sym_to_data_ang.py
        '''
        data = []
        accumulator = 0
        pi = math.pi

        for j in symbol:
            phase = -pi + (j-1)*(2*pi/(self.N))
            temp = np.zeros((self.N, 1), complex)
            for i in range(0, self.N):
                accumulator = accumulator + phase
                polar_radius = 1
                
                x = polar_radius * math.cos(accumulator)
                y = polar_radius * math.sin(accumulator)
                temp[i] = complex(x, y)
                phase = phase + (2*pi/self.N)
                
            data = temp
            
        data = np.squeeze(data)
        
        # downsample the signal by adding zeros in the fft 
        if(self.UPSAMP != 0):
            data_fft = fft.fft(data)
            nz_h_1 = data_fft[:int(len(data_fft)/2)] 
            zeroes_h = np.squeeze(np.zeros(((self.UPSAMP-1)*len(data_fft), 1), complex))
            nz_h_2 = data_fft[int(len(data_fft)/2):]
            parts = np.concatenate((nz_h_1, zeroes_h , nz_h_2))
            data_upsamp = fft.ifft(parts)           
            data = data_upsamp
                
        return data